import crypto_utils as cu
"""
    &           bitwise AND operation.
    |           bitwise OR operation. 
    ^           bitwise exclusive-OR operation.
    bytes_rol() logical left shift operation. 
    >>          logical right shift operation.
    <<<         left rotation operation.
    ~y          bitwise complement of y.
    0x          hexadecimal representation.
    
    Constant values : masks of different lengths and sigma, which represents "keys" in the F-function
    Hexadecimal notation.
"""
MASK8 = 0xff
MASK32 = 0xffffffff
MASK64 = 0xffffffffffffffff
MASK128 = 0xffffffffffffffffffffffffffffffff
sigma =[
    0xA09E667F3BCC908B,
    0xB67AE8584CAA73B2,
    0xC6EF372FE94F82BE,
    0x54FF53A5F1D36F1C,
    0x10E527FADE682D1D,
    0xB05688C2B3E6C1FD
]
"""
    Class CamelliaKey. Represents the key scheduling part.
"""
class CamelliaKey(object):
    """
    init initialize the object.
    Inputs: length of the key, camellia key
    task: We divide the ckey as 2 blocks KL (key left) and KR (key right) which depends of the length of the key.
    """
    def __init__(self, length, ckey):
        self.length = length
        if length == 128:
            self.KL = ckey
            self.KR = 0
        elif length == 192:
            self.KL = Ckey >> 64
            self.KR = ((ckey & MASK64) << 64) | (~(ckey & MASK64))
        else:
            self.KL = ckey >> 128
            self.KR = ckey & MASK128

    def generate_ka(self):
        temp1 = (self.KL ^ self.KR) >> 64
        temp2 = (self.KL ^ self.KR) & MASK64
        temp2 ^= f_function(temp1, sigma[0])
        temp1 ^= f_function(temp2, sigma[1])
        temp1 ^= (self.KL >> 64)
        temp2 ^= (self.KL & MASK64)
        temp2 ^= f_function(temp1, sigma[2])
        temp1 ^= f_function(temp2, sigma[3])
        ka = (temp1 << 64) | temp2
        return ka

    def generate_kb(self, ka):
        temp1 = (ka ^ self.KR) >> 64
        temp2 = (ka ^ self.KR) & MASK64
        temp2 ^= f_function(temp1, sigma[4])
        temp1 ^= f_function(temp2, sigma[5])
        kb = (temp1 << 64) | temp2
        return kb

    def generate_subkeys_128(self, ka, kb):
        if self.length == 128:
            k1 = ka >> 64
            k2 = ka & MASK64
            k3 = cu.bytes_rol(self.KL, 15) >> 64
            k4 = cu.bytes_rol(self.KL, 15) & MASK64
            k5 = cu.bytes_rol(ka, 15) >> 64
            k6 = cu.bytes_rol(ka, 15) & MASK64
            k7 = cu.bytes_rol(self.KL, 45) >> 64
            k8 = cu.bytes_rol(self.KL, 45) & MASK64
            k9 = cu.bytes_rol(ka, 45) >> 64
            k10 = cu.bytes_rol(self.KL, 60) & MASK64
            k11 = cu.bytes_rol(ka, 60) >> 64
            k12 = cu.bytes_rol(ka, 60) & MASK64
            k13 = cu.bytes_rol(self.KL, 94) >> 64
            k14 = cu.bytes_rol(self.KL, 94) & MASK64
            k15 = cu.bytes_rol(ka, 94) >> 64
            k16 = cu.bytes_rol(ka, 94) & MASK64
            k17 = cu.bytes_rol(self.KL, 111) >> 64
            k18 = cu.bytes_rol(self.KL, 111) & MASK64
            subk128 = [k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18]
            return subk128
        else:
            k1 = kb >> 64
            k2 = kb & MASK64
            k3 = cu.bytes_rol(self.KR, 15) >> 64
            k4 = cu.bytes_rol(self.KR, 15) & MASK64
            k5 = cu.bytes_rol(ka, 15) >> 64
            k6 = cu.bytes_rol(ka, 15) & MASK64
            k7 = cu.bytes_rol(kb, 30) >> 64
            k8 = cu.bytes_rol(kb, 30) & MASK64
            k9 = cu.bytes_rol(self.KL, 45) >> 64
            k10 = cu.bytes_rol(self.KL, 45) & MASK64
            k11 = cu.bytes_rol(ka, 45) >> 64
            k12 = cu.bytes_rol(ka, 45) & MASK64
            k13 = cu.bytes_rol(self.KR, 60) >> 64
            k14 = cu.bytes_rol(self.KR, 60) & MASK64
            k15 = cu.bytes_rol(kb, 60) >> 64
            k16 = cu.bytes_rol(kb, 60) & MASK64
            k17 = cu.bytes_rol(self.KL, 77) >> 64
            k18 = cu.bytes_rol(self.KL, 77) & MASK64
            k19 = cu.bytes_rol(self.KR, 94) >> 64
            k20 = cu.bytes_rol(self.KR, 94) & MASK64
            k21 = cu.bytes_rol(ka, 94) >> 64
            k22 = cu.bytes_rol(ka, 94) & MASK64
            k23 = cu.bytes_rol(self.KL, 111) >> 64
            k24 = cu.bytes_rol(self.KL, 111) & MASK64
            subk = [k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21,
                    k22, k23, k24]
            return subk

    """
        Generate_subkw aims to generate all the subkeys kw1, kw2, kw3 and kw4.
        inputs : camelliakey and k, which is ka in case of lengthkey=128, and kb is lengthkey=192,256 bits
    """

    def generate_subkw(self, k):
        kw1 = self.KL >> 64
        kw2 = self.KL & MASK64
        kw3 = cu.bytes_rol(k, 111) >> 64
        kw4 = cu.bytes_rol(k, 111) & MASK64
        subkweys = [kw1, kw2, kw3, kw4]
        return subkweys

    def generate_subke_128(self, ka):
        if self.length == 128:
            ke1 = cu.bytes_rol(ka, 30) >> 64
            ke2 = cu.bytes_rol(ka, 30) & MASK64
            ke3 = cu.bytes_rol(self.KL, 77) >> 64
            ke4 = cu.bytes_rol(self.KL, 77) & MASK64
            subke128 = [ke1, ke2, ke3, ke4]
            return subke128
        else:
            ke1 = cu.bytes_rol(self.KR, 30) >> 64
            ke2 = cu.bytes_rol(self.KR, 30) & MASK64
            ke3 = cu.bytes_rol(self.KL, 60) >> 64
            ke4 = cu.bytes_rol(self.KL, 60) & MASK64
            ke5 = cu.bytes_rol(ka, 77) >> 64
            ke6 = cu.bytes_rol(ka, 77) >> MASK64
            subke = [ke1, ke2, ke3, ke4, ke5, ke6]
            return subke


def divide_text_128(message):
    mleft = message >> 64
    mright = message & MASK64
    subtext = [mleft, mright]
    return subtext


def feistel(subtext, subkw, subk, subke):
    # Prewhitening
    temp1 = subtext[0] ^ subkw[0]
    temp2 = subtext[1] ^ subkw[1]
    # begin of first 6-round feistel
    temp2 ^= f_function(temp1, subk[0])
    temp1 ^= f_function(temp2, subk[1])
    temp2 ^= f_function(temp1, subk[2])
    temp1 ^= f_function(temp2, subk[3])
    temp2 ^= f_function(temp1, subk[4])
    temp1 ^= f_function(temp2, subk[5])
    # insertion of fl and flinv functions with ke1 and ke2
    temp1 = fl_function(temp1, subke[0])
    temp2 = flinv_function(temp2, subke[1])
    # continue with another 6-round feistel
    temp2 ^= f_function(temp1, subk[6])
    temp1 ^= f_function(temp2, subk[7])
    temp2 ^= f_function(temp1, subk[8])
    temp1 ^= f_function(temp2, subk[9])
    temp2 ^= f_function(temp1, subk[10])
    temp1 ^= f_function(temp2, subk[11])
    # new insertion of fl and flinv functions with ke3 and ke4
    temp1 = fl_function(temp1, subke[2])
    temp2 = flinv_function(temp2, subke[3])
    # last 6-round feistel for key 128bits
    temp2 ^= f_function(temp1, subk[12])
    temp1 ^= f_function(temp2, subk[13])
    temp2 ^= f_function(temp1, subk[14])
    temp1 ^= f_function(temp2, subk[15])
    temp2 ^= f_function(temp1, subk[16])
    temp1 ^= f_function(temp2, subk[17])
    if self.length != 128:
        temp1 = fl_function(temp1, subke[4])
        temp2 = flinv_function(temp2, subke[5])
        temp2 ^= f_function(temp1, subk[18])
        temp1 ^= f_function(temp2, subk[19])
        temp2 ^= f_function(temp1, subk[20])
        temp1 ^= f_function(temp2, subk[21])
        temp2 ^= f_function(temp1, subk[22])
        temp1 ^= f_function(temp2, subk[23])
    # postwhitening
    d2cipher = temp2 ^ subkw[2]
    d1cipher = temp1 ^ subkw[3]
    return [d1cipher, d2cipher]

def round6feistel(temp1, temp2, subk,firstknb):
    temp2 ^= f_function(temp1, subk[firstknb])
    temp1 ^= f_function(temp2, subk[firstknb+1])
    temp2 ^= f_function(temp1, subk[firstknb+2])
    temp1 ^= f_function(temp2, subk[firstknb+3])
    temp2 ^= f_function(temp1, subk[firstknb+4])
    temp1 ^= f_function(temp2, subk[firstknb+5])
    tab = [temp1, temp2]
    return tab

def f_function(inputdata, subkey):
    x = inputdata ^ subkey
    t1 = x >> 56
    t2 = (x >> 48) & MASK8
    t3 = (x >> 40) & MASK8
    t4 = (x >> 32) & MASK8
    t5 = (x >> 24) & MASK8
    t6 = (x >> 16) & MASK8
    t7 = (x >> 8) & MASK8
    t8 = x & MASK8
    t1 = SBOX1[t1]
    t2 = SBOX2[t2]
    t3 = SBOX3[t3]
    t4 = SBOX4[t4]
    t5 = SBOX2[t5]
    t6 = SBOX3[t6]
    t7 = SBOX4[t7]
    t8 = SBOX1[t8]
    y1 = t1 ^ t3 ^ t4 ^ t6 ^ t7 ^ t8
    y2 = t1 ^ t2 ^ t4 ^ t5 ^ t7 ^ t8
    y3 = t1 ^ t2 ^ t3 ^ t5 ^ t6 ^ t8
    y4 = t2 ^ t3 ^ t4 ^ t5 ^ t6 ^ t7
    y5 = t1 ^ t2 ^ t6 ^ t7 ^ t8
    y6 = t2 ^ t3 ^ t5 ^ t7 ^ t8
    y7 = t3 ^ t4 ^ t5 ^ t6 ^ t8
    y8 = t1 ^ t4 ^ t5 ^ t6 ^ t7
    fout = (y1 << 56) | (y2 << 48) | (y3 << 40) | (y4 << 32) | (y5 << 24) | (y6 << 16) | (y7 << 8) | y8
    return fout

"""
    Fl_function takes two parameters :
    - inputdata (64-bit)
    - subkey (64-bit)
    return: 
    - data flout (64-bit)
    use of variables :
    x1, x2, k1, k2 (32-bit unsigned integer)
"""
def fl_function(inputdata, subkey):
    x1 = inputdata >> 32
    x2 = inputdata & MASK32
    k1 = subkey >> 32
    k2 = subkey & MASK32
    x2 ^= cu.bytes_rol((x1 & k1),1)
    x1 ^= (x2 | k2)
    flout = (x1 << 32) | x2
    return flout
"""
    Flinv_function si the inverse function of the FL_function
    Flinv_function takes two parameters :
    - inputdata (64-bit)
    - subkey (64-bit)
    return: 
    - data flout (64-bit)
    use of variables :
    y1, y2, k1, k2 (32-bit unsigned integer)   
"""
def flinv_function(inputdata, subkey):
    y1 = inputdata >> 32
    y2 = inputdata & MASK32
    k1 = subkey >> 32
    k2 = subkey & MASK32
    y1 ^= (y2 | k2)
    y2 ^= cu.bytes_rol((y1 & k1),1)
    flinvout = (y1 << 32) | y2
    return flinvout

def encryption128(message, key):
    subtext = divide_text_128(message)
    subk = key.generate_subkeys(key, key.generate_ka())
    subkw = key.generate_subkw(key, key.generate_ka())
    subke = key.generate_subke(key, key.generate_ka())
    dataforcypher = feistel(subtext, subkw, subk, subke)
    # construction of the ciphertext 128 bits from temp1 and temp2
    ciphertext = (dataforcypher[1] << 64) | dataforcypher[0]
    return ciphertext

def inverse_subkweys(subkw):
    invsubkw = [subkw[2], subkw[3], subkw[0], subkw[1]]
    return invsubkw

def inverse_subkeys(subk):
    subk.reverse()
    return subk

def inverse_subke (subke):
    subke.reverse()
    return subkwe

def decryption128(ciphertext, subkw, subk, subke):
    subcipher = divide_text_128(ciphertext)
    invsubkw = inverse_subkwhite(subkw)
    invsubk = inverse_subkeys(subk)
    invsubke = inverse_subkeys(subke)
    datafordecipher = feistel(subcipher,invsubkw, invsubk, invsubke)
    plaintext = (datafordecipher[0] << 64) | datafordecipher[1]
    return plaintext

"""
    CamelliaCBCParameter ::= CamelliaIV  --  Initialization Vector
    CamelliaIV ::= OCTET STRING (SIZE(16))
"""